/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory();
  } else {
    root.LDTRTrigParser = factory();
  }
})(this, function() {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleIndices = { trigDoc: 0 },
        peg$startRuleIndex   = 0,

        peg$consts = [
          function(data) {
                  var currentContext = {}, currentGraph = [];
                  var result = [
                      {'@context': currentContext, '@graph': currentGraph}
                  ];
                  var vocab = '';

                  function cleanupPNameTags(item, vocab) {
                      var id = item['@id'];
                      if (item[PNAME_TAG]) {
                          delete item[PNAME_TAG];
                          if (id === null) {
                              item['@id'] = vocab;
                          } else if (id.indexOf(':') === -1) {
                              item['@id'] = vocab + id;
                          }
                      }
                      for (var key in item) {
                          var o = item[key];
                          if (typeof o === 'object') {
                              cleanupPNameTags(o, vocab);
                          }
                      }
                  }

                  for (var item of data) {
                      var ctxItem = item['@context'];
                      if (ctxItem) {
                          if (currentGraph.length !== 0) {
                              currentContext = {};
                              currentGraph = [];
                              result.push(
                                  {'@context': currentContext, '@graph': currentGraph}
                              );
                          }
                          assign(currentContext, ctxItem);
                          vocab = currentContext['@vocab'] || '';
                      } else if (Array.isArray(item)) {
                          currentGraph.push.apply(currentGraph, item);
                      } else {
                          cleanupPNameTags(item, vocab);
                          currentGraph.push(item);
                      }
                  }
                  return result.length === 1? result[0] : result;
              },
          function(g) { return g['@graph']; },
          "graph",
          peg$literalExpectation("GRAPH", true),
          function(name, wg) {
                  return assign(name, wg);
              },
          ".",
          peg$literalExpectation(".", false),
          function(subject, pos) { return pos; },
          function(subject, labelled) {
                  if (typeof labelled['@graph'] !== 'undefined') {
                      return assign(subject, labelled);
                  } else {
                      return reducePairs(subject, labelled);
                  }
              },
          function(bnpairs, pos) {
                  return pos? reducePairs(bnpairs, pos) : bnpairs;
              },
          function(collection, pos) {
                  return pos? reducePairs(bnpairs, pos) : bnpairs;
              },
          "{",
          peg$literalExpectation("{", false),
          "}",
          peg$literalExpectation("}", false),
          function(tb) {
                  return {'@graph': tb};
              },
          function(triples, block) { return block; },
          function(triples, next) {
                  var items = [triples];
                  if (next) {
                      items.push.apply(items, next);
                  }
                  return items;
              },
          "@prefix",
          peg$literalExpectation("@prefix", false),
          function(pfx, iriref) {
                  return prefix(pfx, iriref);
              },
          "@base",
          peg$literalExpectation("@base", false),
          function(iriref) {
                  return base(iriref);
              },
          "prefix",
          peg$literalExpectation("PREFIX", true),
          "base",
          peg$literalExpectation("BASE", true),
          function(subject, pos) {
                  return reducePairs(subject, pos);
              },
          ";",
          peg$literalExpectation(";", false),
          function(verb, objectList, vol) { return vol; },
          function(verb, objectList, rest) {
                  if (verb === '@type') {
                      objectList = toSymbols(objectList);
                  }
                  var po = toPair(verb, objectList);
                  var pairs = [po];
                  for (var pair of rest) {
                      if (pair === null) // last ';', so we could also break
                          continue
                      var restList = pair[1];
                      if (pair[0] === '@type') {
                          restList = toSymbols(restList);
                      }
                      po = toPair(pair[0], restList);
                      pairs.push(po);
                  }
                  return pairs;
              },
          ",",
          peg$literalExpectation(",", false),
          function(first, object) { return object; },
          function(first, remainder) {
                  if (remainder.length > 0) {
                      var objects = [first];
                      for (var object of remainder) {
                          objects.push(object);
                      }
                      return objects;
                  } else {
                      return first;
                  }
              },
          "a",
          peg$literalExpectation("a", false),
          function() {return '@type'; },
          function(verb) {
                  var id = verb['@id'];
                  if (id)
                      return id;
                  return verb;
              },
          function(literal) {
                  return literal;
              },
          "[",
          peg$literalExpectation("[", false),
          "]",
          peg$literalExpectation("]", false),
          function(pos) {
                  return reducePairs({}, pos);
              },
          "(",
          peg$literalExpectation("(", false),
          ")",
          peg$literalExpectation(")", false),
          function(collection) {
                  return {'@list': collection};
              },
          "^^",
          peg$literalExpectation("^^", false),
          function(rdfliteral, datatype) { return {'@type': datatype['@id']}; },
          function(rdfliteral, tag) {
                  var value = rdfliteral;
                  if (tag !== null) {
                      value = {'@value': rdfliteral};
                      assign(value, tag);
                  }
                  return value;
              },
          "true",
          peg$literalExpectation("true", false),
          function() { return true; },
          "false",
          peg$literalExpectation("false", false),
          function() { return false; },
          function(value) {
                  return value;
              },
          function(iri) {
                  return iri;
              },
          function(pname) {
              var item = {"@id": pname};
              item[PNAME_TAG] = true;
              return item;
          },
          function(bnode) {
                  return bnode;
              },
          "<",
          peg$literalExpectation("<", false),
          /^[^\0- <>"{}|\^`\\]/,
          peg$classExpectation([["\0", " "], "<", ">", "\"", "{", "}", "|", "^", "`", "\\"], true, false),
          ">",
          peg$literalExpectation(">", false),
          function(iriref) {
                  return {"@id": iriref.join('')};
              },
          ":",
          peg$literalExpectation(":", false),
          function(pfx) {
                  return pfx;
              },
          function(ns, l) {
                  return (ns === null? '' : ns + ':') + l;
              },
          "_:",
          peg$literalExpectation("_:", false),
          /^[0-9]/,
          peg$classExpectation([["0", "9"]], false, false),
          function(lead, first, chars) { return chars.join(''); },
          function(lead, first, rest) {
                  var label = first + (rest? rest.join('') : '');
                  return {'@id': lead + label};
              },
          "@",
          peg$literalExpectation("@", false),
          /^[a-zA-Z]/,
          peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
          "-",
          peg$literalExpectation("-", false),
          /^[a-zA-Z0-9]/,
          peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
          function(tag, subtag) {
                  var sub = (subtag.length? subtag.map(function (it) {
                      return it[0] + it[1].join(''); }).join('') : '');
                  return {"@language": tag.join('') + sub};
              },
          /^[+\-]/,
          peg$classExpectation(["+", "-"], false, false),
          function(sign, digits) {
                  var i = parseInt(digits.join(''), 10);
                  if (sign === '-')
                      i = -1 * i;
                  return i;
              },
          function(sign, whole, fraction) {
                      return (whole? whole.join('') : '') + '.' + fraction.join('');
                  },
          function(sign, digits) {
                  return parseFloat((sign || '') + digits, 10);
              },
          function(sign, whole, fraction, exp) {
                      return whole.join('') + '.' +
                          (fraction? fraction.join('') : '') + exp;
                  },
          function(sign, fraction, exp) {
                      return fraction.join('') + exp;
                  },
          function(sign, whole, exp) {
                      return whole.join('') + exp;
                  },
          /^[eE]/,
          peg$classExpectation(["e", "E"], false, false),
          function(e, sign, digits) {
                  return e + (sign || '') + digits.join('');
              },
          "\"",
          peg$literalExpectation("\"", false),
          /^[^"\\\n\r]/,
          peg$classExpectation(["\"", "\\", "\n", "\r"], true, false),
          function(value) {
                  return value.join('');
              },
          "'",
          peg$literalExpectation("'", false),
          /^[^'\\\n\r]/,
          peg$classExpectation(["'", "\\", "\n", "\r"], true, false),
          "'''",
          peg$literalExpectation("'''", false),
          "''",
          peg$literalExpectation("''", false),
          /^[^'\\]/,
          peg$classExpectation(["'", "\\"], true, false),
          function(first, rest) { return (first || '') + rest; },
          "\"\"\"",
          peg$literalExpectation("\"\"\"", false),
          "\"\"",
          peg$literalExpectation("\"\"", false),
          /^[^"\\]/,
          peg$classExpectation(["\"", "\\"], true, false),
          "\\u",
          peg$literalExpectation("\\u", false),
          function(hex) {
                  return String.fromCharCode(parseInt(hex.join(''), 16));
              },
          "\\U",
          peg$literalExpectation("\\U", false),
          "\\",
          peg$literalExpectation("\\", false),
          /^[tbnrf"'\\]/,
          peg$classExpectation(["t", "b", "n", "r", "f", "\"", "'", "\\"], false, false),
          function(chr) {
                  return echars[chr];
              },
          " ",
          peg$literalExpectation(" ", false),
          "\t",
          peg$literalExpectation("\t", false),
          "\r",
          peg$literalExpectation("\r", false),
          "\n",
          peg$literalExpectation("\n", false),
          function() { return {}; },
          /^[A-Z]/,
          peg$classExpectation([["A", "Z"]], false, false),
          /^[a-z]/,
          peg$classExpectation([["a", "z"]], false, false),
          /^[\xC0-\xD6]/,
          peg$classExpectation([["\xC0", "\xD6"]], false, false),
          /^[\xD8-\xF6]/,
          peg$classExpectation([["\xD8", "\xF6"]], false, false),
          /^[\xF8-\u02FF]/,
          peg$classExpectation([["\xF8", "\u02FF"]], false, false),
          /^[\u0370-\u037D]/,
          peg$classExpectation([["\u0370", "\u037D"]], false, false),
          /^[\u037F-\u1FFF]/,
          peg$classExpectation([["\u037F", "\u1FFF"]], false, false),
          /^[\u200C-\u200D]/,
          peg$classExpectation([["\u200C", "\u200D"]], false, false),
          /^[\u2070-\u218F]/,
          peg$classExpectation([["\u2070", "\u218F"]], false, false),
          /^[\u2C00-\u2FEF]/,
          peg$classExpectation([["\u2C00", "\u2FEF"]], false, false),
          /^[\u3001-\uD7FF]/,
          peg$classExpectation([["\u3001", "\uD7FF"]], false, false),
          /^[\uF900-\uFDCF]/,
          peg$classExpectation([["\uF900", "\uFDCF"]], false, false),
          /^[\uFDF0-\uFFFD]/,
          peg$classExpectation([["\uFDF0", "\uFFFD"]], false, false),
          "_",
          peg$literalExpectation("_", false),
          "\xB7",
          peg$literalExpectation("\xB7", false),
          /^[\u0300-\u036F]/,
          peg$classExpectation([["\u0300", "\u036F"]], false, false),
          /^[\u203F-\u2040]/,
          peg$classExpectation([["\u203F", "\u2040"]], false, false),
          function(first, chars) { return chars.join(''); },
          function(first, rest) {
                  return first + (rest? rest.join('') : '');
              },
          "%",
          peg$literalExpectation("%", false),
          function(a, b) { return '%' + a + b; },
          /^[A-F]/,
          peg$classExpectation([["A", "F"]], false, false),
          /^[a-f]/,
          peg$classExpectation([["a", "f"]], false, false),
          "~",
          peg$literalExpectation("~", false),
          "!",
          peg$literalExpectation("!", false),
          "$",
          peg$literalExpectation("$", false),
          "&",
          peg$literalExpectation("&", false),
          "*",
          peg$literalExpectation("*", false),
          "+",
          peg$literalExpectation("+", false),
          "=",
          peg$literalExpectation("=", false),
          "/",
          peg$literalExpectation("/", false),
          "?",
          peg$literalExpectation("?", false),
          "#",
          peg$literalExpectation("#", false),
          function(chr) {
                  return chr;
              },
          /^[^\r\n]/,
          peg$classExpectation(["\r", "\n"], true, false),
          /^[\r\n]/,
          peg$classExpectation(["\r", "\n"], false, false)
        ],

        peg$bytecode = [
          peg$decode("%;X/M#$;'.# &;!0)*;'.# &;!&/1$;X/($8#: #!!)(#'#(\"'#&'#"),
          peg$decode(";\".l &%;$/' 8!:!!! ).Z &;#.T &%;X/J#3\"\"\"5%7#/;$;&/2$;$/)$8$:$$\"! )($'#(#'#(\"'#&'#"),
          peg$decode("%;&/`#;$.K &%;-/A#;X/8$2%\"\"6%7&/)$8#:'#\"$\")(#'#(\"'#&'#/)$8\":(\"\"! )(\"'#&'#"),
          peg$decode("%;4/O#;-.\" &\"/A$;X/8$2%\"\"6%7&/)$8$:)$\"#\")($'#(#'#(\"'#&'#.T &%;5/J#;-/A$;X/8$2%\"\"6%7&/)$8$:*$\"#\")($'#(#'#(\"'#&'#"),
          peg$decode("%;X/f#2+\"\"6+7,/W$;%.\" &\"/I$;X/@$2-\"\"6-7./1$;X/($8&:/&!#)(&'#(%'#($'#(#'#(\"'#&'#"),
          peg$decode("%;,/[#%2%\"\"6%7&/7#;%.\" &\"/)$8\":0\"\"# )(\"'#&'#.\" &\"/)$8\":1\"\"! )(\"'#&'#"),
          peg$decode(";:.# &;<"),
          peg$decode(";(./ &;).) &;*.# &;+"),
          peg$decode("%22\"\"6273/n#;X/e$;>/\\$;X/S$;=/J$;X/A$2%\"\"6%7&/2$;X/)$8(:4(\"%#)(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
          peg$decode("%25\"\"6576/[#;X/R$;=/I$;X/@$2%\"\"6%7&/1$;X/($8&:7&!#)(&'#(%'#($'#(#'#(\"'#&'#"),
          peg$decode("%38\"\"5&79/V#;X/M$;>/D$;X/;$;=/2$;X/)$8&:4&\"#!)(&'#(%'#($'#(#'#(\"'#&'#"),
          peg$decode("%3:\"\"5$7;/C#;X/:$;=/1$;X/($8$:7$!!)($'#(#'#(\"'#&'#"),
          peg$decode("%;0/2#;-/)$8\":<\"\"! )(\"'#&'#.; &%;4/1#;-.\" &\"/#$+\")(\"'#&'#"),
          peg$decode("%;//\xBC#;./\xB3$$%2=\"\"6=7>/K#%;//,#;./#$+\")(\"'#&'#.\" &\"/*$8\":?\"#%$ )(\"'#&'#0[*%2=\"\"6=7>/K#%;//,#;./#$+\")(\"'#&'#.\" &\"/*$8\":?\"#%$ )(\"'#&'#&/3$;X/*$8$:@$##\"!)($'#(#'#(\"'#&'#"),
          peg$decode("%;1/\x9B#$%;X/J#2A\"\"6A7B/;$;X/2$;1/)$8$:C$\"& )($'#(#'#(\"'#&'#0T*%;X/J#2A\"\"6A7B/;$;X/2$;1/)$8$:C$\"& )($'#(#'#(\"'#&'#&/)$8\":D\"\"! )(\"'#&'#"),
          peg$decode("%;X/Q#;:.4 &%2E\"\"6E7F/& 8!:G! )/1$;X/($8#:H#!!)(#'#(\"'#&'#"),
          peg$decode(";:.# &;3"),
          peg$decode(";:./ &;3.) &;4.# &;2"),
          peg$decode("%;X/F#;7.) &;6.# &;8/1$;X/($8#:I#!!)(#'#(\"'#&'#"),
          peg$decode(";<.# &;5"),
          peg$decode("%;X/X#2J\"\"6J7K/I$;-/@$2L\"\"6L7M/1$;X/($8%:N%!\")(%'#($'#(#'#(\"'#&'#"),
          peg$decode("%;X/q#2O\"\"6O7P/b$;X/Y$$;10#*;1&/I$;X/@$2Q\"\"6Q7R/1$;X/($8':S'!#)(''#(&'#(%'#($'#(#'#(\"'#&'#"),
          peg$decode(";D.) &;C.# &;B"),
          peg$decode("%;9/\\#;A.B &%2T\"\"6T7U/2#;:/)$8\":V\"\"# )(\"'#&'#.\" &\"/)$8\":W\"\"! )(\"'#&'#"),
          peg$decode("%2X\"\"6X7Y/& 8!:Z! ).4 &%2[\"\"6[7\\/& 8!:]! )"),
          peg$decode("%;X/L#;H./ &;I.) &;F.# &;G/1$;X/($8#:^#!!)(#'#(\"'#&'#"),
          peg$decode("%;X/@#;=.# &;;/1$;X/($8#:_#!!)(#'#(\"'#&'#"),
          peg$decode("%;?.# &;>/' 8!:`!! )"),
          peg$decode("%;X/@#;@.# &;N/1$;X/($8#:a#!!)(#'#(\"'#&'#"),
          peg$decode("%2b\"\"6b7c/_#$4d\"\"5!7e.# &;J0/*4d\"\"5!7e.# &;J&/7$2f\"\"6f7g/($8#:h#!!)(#'#(\"'#&'#"),
          peg$decode("%;R.\" &\"/7#2i\"\"6i7j/($8\":k\"!!)(\"'#&'#"),
          peg$decode("%;>/2#;S/)$8\":l\"\"! )(\"'#&'#"),
          peg$decode("%2m\"\"6m7n/\xA9#;P.) &4o\"\"5!7p/\x94$$%%2%\"\"6%7&/,#;Q/#$+\")(\"'#&'#/) 8!:q!#$# ).# &;Q0P*%%2%\"\"6%7&/,#;Q/#$+\")(\"'#&'#/) 8!:q!#$# ).# &;Q&/*$8#:r##\"! )(#'#(\"'#&'#"),
          peg$decode("%2s\"\"6s7t/\xBF#$4u\"\"5!7v/,#0)*4u\"\"5!7v&&&#/\x9D$$%2w\"\"6w7x/E#$4y\"\"5!7z/,#0)*4y\"\"5!7z&&&#/#$+\")(\"'#&'#0U*%2w\"\"6w7x/E#$4y\"\"5!7z/,#0)*4y\"\"5!7z&&&#/#$+\")(\"'#&'#&/)$8#:{#\"! )(#'#(\"'#&'#"),
          peg$decode("%4|\"\"5!7}.\" &\"/K#$4o\"\"5!7p/,#0)*4o\"\"5!7p&&&#/)$8\":~\"\"! )(\"'#&'#"),
          peg$decode("%4|\"\"5!7}.\" &\"/\x87#%$4o\"\"5!7p0)*4o\"\"5!7p&/[#2%\"\"6%7&/L$$4o\"\"5!7p/,#0)*4o\"\"5!7p&&&#/*$8#:\x7F##$\" )(#'#(\"'#&'#/)$8\":\x80\"\"! )(\"'#&'#"),
          peg$decode("%4|\"\"5!7}.\" &\"/\u0112#%$4o\"\"5!7p/,#0)*4o\"\"5!7p&&&#/_#2%\"\"6%7&/P$$4o\"\"5!7p0)*4o\"\"5!7p&/4$;E/+$8$:\x81$$%#! )($'#(#'#(\"'#&'#.\x9E &%2%\"\"6%7&/U#$4o\"\"5!7p/,#0)*4o\"\"5!7p&&&#/3$;E/*$8#:\x82##$! )(#'#(\"'#&'#.V &%$4o\"\"5!7p/,#0)*4o\"\"5!7p&&&#/3#;E/*$8\":\x83\"##! )(\"'#&'#/)$8\":\x80\"\"! )(\"'#&'#"),
          peg$decode("%4\x84\"\"5!7\x85/`#4|\"\"5!7}.\" &\"/L$$4o\"\"5!7p/,#0)*4o\"\"5!7p&&&#/*$8#:\x86##\"! )(#'#(\"'#&'#"),
          peg$decode("%2\x87\"\"6\x877\x88/k#$4\x89\"\"5!7\x8A.) &;K.# &;J05*4\x89\"\"5!7\x8A.) &;K.# &;J&/7$2\x87\"\"6\x877\x88/($8#:\x8B#!!)(#'#(\"'#&'#"),
          peg$decode("%2\x8C\"\"6\x8C7\x8D/k#$4\x8E\"\"5!7\x8F.) &;K.# &;J05*4\x8E\"\"5!7\x8F.) &;K.# &;J&/7$2\x8C\"\"6\x8C7\x8D/($8#:\x8B#!!)(#'#(\"'#&'#"),
          peg$decode("%2\x90\"\"6\x907\x91/\xCB#$%2\x8C\"\"6\x8C7\x8D.) &2\x92\"\"6\x927\x93.\" &\"/D#4\x94\"\"5!7\x95.) &;K.# &;J/)$8\":\x96\"\"! )(\"'#&'#0e*%2\x8C\"\"6\x8C7\x8D.) &2\x92\"\"6\x927\x93.\" &\"/D#4\x94\"\"5!7\x95.) &;K.# &;J/)$8\":\x96\"\"! )(\"'#&'#&/7$2\x90\"\"6\x907\x91/($8#:\x8B#!!)(#'#(\"'#&'#"),
          peg$decode("%2\x97\"\"6\x977\x98/\xCB#$%2\x87\"\"6\x877\x88.) &2\x99\"\"6\x997\x9A.\" &\"/D#4\x9B\"\"5!7\x9C.) &;K.# &;J/)$8\":\x96\"\"! )(\"'#&'#0e*%2\x87\"\"6\x877\x88.) &2\x99\"\"6\x997\x9A.\" &\"/D#4\x9B\"\"5!7\x9C.) &;K.# &;J/)$8\":\x96\"\"! )(\"'#&'#&/7$2\x97\"\"6\x977\x98/($8#:\x8B#!!)(#'#(\"'#&'#"),
          peg$decode("%2\x9D\"\"6\x9D7\x9E/V#%;V/>#;V/5$;V/,$;V/#$+$)($'#(#'#(\"'#&'#/($8\":\x9F\"! )(\"'#&'#.\x8A &%2\xA0\"\"6\xA07\xA1/z#%;V/b#;V/Y$;V/P$;V/G$;V/>$;V/5$;V/,$;V/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/($8\":\x9F\"! )(\"'#&'#"),
          peg$decode("%2\xA2\"\"6\xA27\xA3/7#4\xA4\"\"5!7\xA5/($8\":\xA6\"! )(\"'#&'#"),
          peg$decode("%2O\"\"6O7P/;#;X/2$2Q\"\"6Q7R/#$+#)(#'#(\"'#&'#"),
          peg$decode("2\xA7\"\"6\xA77\xA8.A &2\xA9\"\"6\xA97\xAA.5 &2\xAB\"\"6\xAB7\xAC.) &2\xAD\"\"6\xAD7\xAE"),
          peg$decode("%2J\"\"6J7K/?#;X/6$2L\"\"6L7M/'$8#:\xAF# )(#'#(\"'#&'#"),
          peg$decode("4\xB0\"\"5!7\xB1.\xAD &4\xB2\"\"5!7\xB3.\xA1 &4\xB4\"\"5!7\xB5.\x95 &4\xB6\"\"5!7\xB7.\x89 &4\xB8\"\"5!7\xB9.} &4\xBA\"\"5!7\xBB.q &4\xBC\"\"5!7\xBD.e &4\xBE\"\"5!7\xBF.Y &4\xC0\"\"5!7\xC1.M &4\xC2\"\"5!7\xC3.A &4\xC4\"\"5!7\xC5.5 &4\xC6\"\"5!7\xC7.) &4\xC8\"\"5!7\xC9"),
          peg$decode(";O.) &2\xCA\"\"6\xCA7\xCB"),
          peg$decode(";P.Y &2w\"\"6w7x.M &4o\"\"5!7p.A &2\xCC\"\"6\xCC7\xCD.5 &4\xCE\"\"5!7\xCF.) &4\xD0\"\"5!7\xD1"),
          peg$decode("%;O/\x91#$%%2%\"\"6%7&/,#;Q/#$+\")(\"'#&'#/( 8!:\xD2!\"# ).# &;Q0O*%%2%\"\"6%7&/,#;Q/#$+\")(\"'#&'#/( 8!:\xD2!\"# ).# &;Q&/)$8\":\xD3\"\"! )(\"'#&'#"),
          peg$decode("%;P.; &2i\"\"6i7j./ &4o\"\"5!7p.# &;T/\u0109#$%%;Q.; &2%\"\"6%7&./ &2i\"\"6i7j.# &;T/>#;Q./ &2i\"\"6i7j.# &;T/#$+\")(\"'#&'#/( 8!:\xD2!\"# ).5 &;Q./ &2i\"\"6i7j.# &;T0\x8B*%%;Q.; &2%\"\"6%7&./ &2i\"\"6i7j.# &;T/>#;Q./ &2i\"\"6i7j.# &;T/#$+\")(\"'#&'#/( 8!:\xD2!\"# ).5 &;Q./ &2i\"\"6i7j.# &;T&/)$8\":\xD3\"\"! )(\"'#&'#"),
          peg$decode(";U.# &;W"),
          peg$decode("%2\xD4\"\"6\xD47\xD5/;#;V/2$;V/)$8#:\xD6#\"! )(#'#(\"'#&'#"),
          peg$decode("4o\"\"5!7p.5 &4\xD7\"\"5!7\xD8.) &4\xD9\"\"5!7\xDA"),
          peg$decode("%2\xA2\"\"6\xA27\xA3/\u011B#2\xCA\"\"6\xCA7\xCB.\u0101 &2\xDB\"\"6\xDB7\xDC.\xF5 &2%\"\"6%7&.\xE9 &2w\"\"6w7x.\xDD &2\xDD\"\"6\xDD7\xDE.\xD1 &2\xDF\"\"6\xDF7\xE0.\xC5 &2\xE1\"\"6\xE17\xE2.\xB9 &2\x8C\"\"6\x8C7\x8D.\xAD &2O\"\"6O7P.\xA1 &2Q\"\"6Q7R.\x95 &2\xE3\"\"6\xE37\xE4.\x89 &2\xE5\"\"6\xE57\xE6.} &2A\"\"6A7B.q &2=\"\"6=7>.e &2\xE7\"\"6\xE77\xE8.Y &2\xE9\"\"6\xE97\xEA.M &2\xEB\"\"6\xEB7\xEC.A &2\xED\"\"6\xED7\xEE.5 &2s\"\"6s7t.) &2\xD4\"\"6\xD47\xD5/($8\":\xEF\"! )(\"'#&'#"),
          peg$decode("$;M.^ &%2\xED\"\"6\xED7\xEE/N#$4\xF0\"\"5!7\xF10)*4\xF0\"\"5!7\xF1&/2$4\xF2\"\"5!7\xF3/#$+#)(#'#(\"'#&'#0d*;M.^ &%2\xED\"\"6\xED7\xEE/N#$4\xF0\"\"5!7\xF10)*4\xF0\"\"5!7\xF1&/2$4\xF2\"\"5!7\xF3/#$+#)(#'#(\"'#&'#&")
        ],

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleIndices)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$decode(s) {
      var bc = new Array(s.length), i;

      for (i = 0; i < s.length; i++) {
        bc[i] = s.charCodeAt(i) - 32;
      }

      return bc;
    }

    function peg$parseRule(index) {
      var bc    = peg$bytecode[index],
          ip    = 0,
          ips   = [],
          end   = bc.length,
          ends  = [],
          stack = [],
          params, i;

      while (true) {
        while (ip < end) {
          switch (bc[ip]) {
            case 0:
              stack.push(peg$consts[bc[ip + 1]]);
              ip += 2;
              break;

            case 1:
              stack.push(void 0);
              ip++;
              break;

            case 2:
              stack.push(null);
              ip++;
              break;

            case 3:
              stack.push(peg$FAILED);
              ip++;
              break;

            case 4:
              stack.push([]);
              ip++;
              break;

            case 5:
              stack.push(peg$currPos);
              ip++;
              break;

            case 6:
              stack.pop();
              ip++;
              break;

            case 7:
              peg$currPos = stack.pop();
              ip++;
              break;

            case 8:
              stack.length -= bc[ip + 1];
              ip += 2;
              break;

            case 9:
              stack.splice(-2, 1);
              ip++;
              break;

            case 10:
              stack[stack.length - 2].push(stack.pop());
              ip++;
              break;

            case 11:
              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
              ip += 2;
              break;

            case 12:
              stack.push(input.substring(stack.pop(), peg$currPos));
              ip++;
              break;

            case 13:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1]) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 14:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] === peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 15:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (stack[stack.length - 1] !== peg$FAILED) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 16:
              if (stack[stack.length - 1] !== peg$FAILED) {
                ends.push(end);
                ips.push(ip);

                end = ip + 2 + bc[ip + 1];
                ip += 2;
              } else {
                ip += 2 + bc[ip + 1];
              }

              break;

            case 17:
              ends.push(end);
              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

              if (input.length > peg$currPos) {
                end = ip + 3 + bc[ip + 1];
                ip += 3;
              } else {
                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                ip += 3 + bc[ip + 1];
              }

              break;

            case 18:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 19:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 20:
              ends.push(end);
              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                end = ip + 4 + bc[ip + 2];
                ip += 4;
              } else {
                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                ip += 4 + bc[ip + 2];
              }

              break;

            case 21:
              stack.push(input.substr(peg$currPos, bc[ip + 1]));
              peg$currPos += bc[ip + 1];
              ip += 2;
              break;

            case 22:
              stack.push(peg$consts[bc[ip + 1]]);
              peg$currPos += peg$consts[bc[ip + 1]].length;
              ip += 2;
              break;

            case 23:
              stack.push(peg$FAILED);
              if (peg$silentFails === 0) {
                peg$fail(peg$consts[bc[ip + 1]]);
              }
              ip += 2;
              break;

            case 24:
              peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
              ip += 2;
              break;

            case 25:
              peg$savedPos = peg$currPos;
              ip++;
              break;

            case 26:
              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
              for (i = 0; i < bc[ip + 3]; i++) {
                params[i] = stack[stack.length - 1 - params[i]];
              }

              stack.splice(
                stack.length - bc[ip + 2],
                bc[ip + 2],
                peg$consts[bc[ip + 1]].apply(null, params)
              );

              ip += 4 + bc[ip + 3];
              break;

            case 27:
              stack.push(peg$parseRule(bc[ip + 1]));
              ip += 2;
              break;

            case 28:
              peg$silentFails++;
              ip++;
              break;

            case 29:
              peg$silentFails--;
              ip++;
              break;

            default:
              throw new Error("Invalid opcode: " + bc[ip] + ".");
          }
        }

        if (ends.length > 0) {
          end = ends.pop();
          ip = ips.pop();
        } else {
          break;
        }
      }

      return stack[0];
    }



        function assign(target, source) {
            for (var key in source) {
                target[key] = source[key];
            }
            return target;
        }

        function contextItem(key, value) {
            var decl = {}
            decl[key] = value;
            return {'@context': decl};
        }

        function prefix(pfx, iriref) {
            return contextItem(pfx || '@vocab', iriref['@id']);
        }

        function base(iriref) {
            return contextItem('@base', iriref['@id']);
        }

        var PNAME_TAG = "_:neverspace.net,2016-01-10:ldtr:pname";

        function toSymbols(objectList) {
            function reducePname(o) {
                return o[PNAME_TAG]? o['@id'] : o;
                // TODO: if value is not a string, item need to use rdf:type as
                // key for those values instead of @type
            }
            if (Array.isArray(objectList)) {
                return objectList.map(function (o) {
                    return reducePname(o);
                });
            } else {
                return reducePname(objectList);
            }
        }

        function toPair(verb, objectList) {
            var po = {};
            po[verb] = objectList;
            return po;
        }

        function reducePairs(subject, pairs) {
            if (subject === null) {
                subject = '';
            }
            if (typeof subject === 'string') {
                if (subject.indexOf(':') === -1) {
                    subject = ':' + subject;
                }
                subject = {'@id': subject};
            }
            for (var pair of pairs) {
                for (var key in pair) {
                    var value = pair[key];
                    var existing = subject[key];
                    if (typeof existing !== 'undefined') {
                        if (!Array.isArray(existing)) {
                            existing = [existing];
                        }
                        if (Array.isArray(value)) {
                            existing.concat(value);
                        } else {
                            existing.push(value);
                        }
                        value = existing;
                    }
                    subject[key] = value;
                }
            }
            return subject;
        }

        var echars = {
            t: '\t',
            b: '\b',
            n: '\n',
            r: '\r',
            f: '\f',
            '"': '"',
            "'": "'",
            '\\': '\\'
        };



    peg$result = peg$parseRule(peg$startRuleIndex);

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
});
