// Generated by PEG.js v0.11.0-master.f69239d, https://pegjs.org/

function peg$subclass(child, parent) {
  function C() { this.constructor = child; }
  C.prototype = parent.prototype;
  child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  // istanbul ignore next
  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },

    class: function(expectation) {
      var escapedParts = expectation.parts.map(function(part) {
        return Array.isArray(part)
          ? classEscape(part[0]) + "-" + classEscape(part[1])
          : classEscape(part);
      });

      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },

    any: function() {
      return "any character";
    },

    end: function() {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    },

    not: function(expectation) {
      return "not " + describeExpectation(expectation.expected);
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/"/g,  "\\\"")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/\]/g, "\\]")
      .replace(/\^/g, "\\^")
      .replace(/-/g,  "\\-")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = expected.map(describeExpectation);
    var i, j;

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== undefined ? options : {};

  var peg$FAILED = {};

  var peg$startRuleIndices = { trigDoc: 0 };
  var peg$startRuleIndex = 0;

  var peg$literals = [
    "graph",
    ".",
    "{",
    "}",
    "@prefix",
    "@base",
    "prefix",
    "base",
    ";",
    ",",
    "a",
    "[",
    "]",
    "(",
    ")",
    "<<",
    ">>",
    "{|",
    "|}",
    "^^",
    "true",
    "false",
    "<",
    ">",
    ":",
    "_:",
    "@",
    "-",
    "\"",
    "'",
    "'''",
    "''",
    "\"\"\"",
    "\"\"",
    "\\u",
    "\\U",
    "\\",
    " ",
    "\t",
    "\r",
    "\n",
    "_",
    "\xB7",
    "%",
    "~",
    "!",
    "$",
    "&",
    "*",
    "+",
    "=",
    "/",
    "?",
    "#"
  ];
  var peg$regexps = [
  /^[^\0- <>"{}|\^`\\]/,
  /^[0-9]/,
  /^[a-zA-Z]/,
  /^[a-zA-Z0-9]/,
  /^[+\-]/,
  /^[eE]/,
  /^[^"\\\n\r]/,
  /^[^'\\\n\r]/,
  /^[^'\\]/,
  /^[^"\\]/,
  /^[tbnrf"'\\]/,
  /^[A-Z]/,
  /^[a-z]/,
  /^[\xC0-\xD6]/,
  /^[\xD8-\xF6]/,
  /^[\xF8-\u02FF]/,
  /^[\u0370-\u037D]/,
  /^[\u037F-\u1FFF]/,
  /^[\u200C-\u200D]/,
  /^[\u2070-\u218F]/,
  /^[\u2C00-\u2FEF]/,
  /^[\u3001-\uD7FF]/,
  /^[\uF900-\uFDCF]/,
  /^[\uFDF0-\uFFFD]/,
  /^[\u0300-\u036F]/,
  /^[\u203F-\u2040]/,
  /^[A-F]/,
  /^[a-f]/,
  /^[^\r\n]/,
  /^[\r\n]/
];
var peg$expectations = [
  peg$literalExpectation("GRAPH", true),
  peg$literalExpectation(".", false),
  peg$literalExpectation("{", false),
  peg$literalExpectation("}", false),
  peg$literalExpectation("@prefix", false),
  peg$literalExpectation("@base", false),
  peg$literalExpectation("PREFIX", true),
  peg$literalExpectation("BASE", true),
  peg$literalExpectation(";", false),
  peg$literalExpectation(",", false),
  peg$literalExpectation("a", false),
  peg$literalExpectation("[", false),
  peg$literalExpectation("]", false),
  peg$literalExpectation("(", false),
  peg$literalExpectation(")", false),
  peg$literalExpectation("<<", false),
  peg$literalExpectation(">>", false),
  peg$literalExpectation("{|", false),
  peg$literalExpectation("|}", false),
  peg$literalExpectation("^^", false),
  peg$literalExpectation("true", false),
  peg$literalExpectation("false", false),
  peg$literalExpectation("<", false),
peg$classExpectation([["\0", " "], "<", ">", "\"", "{", "}", "|", "^", "`", "\\"], true, false),
    peg$literalExpectation(">", false),
    peg$literalExpectation(":", false),
    peg$literalExpectation("_:", false),
    peg$classExpectation([["0", "9"]], false, false),
    peg$literalExpectation("@", false),
    peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
    peg$literalExpectation("-", false),
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
    peg$classExpectation(["+", "-"], false, false),
    peg$classExpectation(["e", "E"], false, false),
    peg$literalExpectation("\"", false),
    peg$classExpectation(["\"", "\\", "\n", "\r"], true, false),
    peg$literalExpectation("'", false),
    peg$classExpectation(["'", "\\", "\n", "\r"], true, false),
    peg$literalExpectation("'''", false),
    peg$literalExpectation("''", false),
    peg$classExpectation(["'", "\\"], true, false),
    peg$literalExpectation("\"\"\"", false),
    peg$literalExpectation("\"\"", false),
    peg$classExpectation(["\"", "\\"], true, false),
    peg$literalExpectation("\\u", false),
    peg$literalExpectation("\\U", false),
    peg$literalExpectation("\\", false),
    peg$classExpectation(["t", "b", "n", "r", "f", "\"", "'", "\\"], false, false),
    peg$literalExpectation(" ", false),
    peg$literalExpectation("\t", false),
    peg$literalExpectation("\r", false),
    peg$literalExpectation("\n", false),
    peg$classExpectation([["A", "Z"]], false, false),
    peg$classExpectation([["a", "z"]], false, false),
    peg$classExpectation([["\xC0", "\xD6"]], false, false),
    peg$classExpectation([["\xD8", "\xF6"]], false, false),
    peg$classExpectation([["\xF8", "\u02FF"]], false, false),
    peg$classExpectation([["\u0370", "\u037D"]], false, false),
    peg$classExpectation([["\u037F", "\u1FFF"]], false, false),
    peg$classExpectation([["\u200C", "\u200D"]], false, false),
    peg$classExpectation([["\u2070", "\u218F"]], false, false),
    peg$classExpectation([["\u2C00", "\u2FEF"]], false, false),
    peg$classExpectation([["\u3001", "\uD7FF"]], false, false),
    peg$classExpectation([["\uF900", "\uFDCF"]], false, false),
    peg$classExpectation([["\uFDF0", "\uFFFD"]], false, false),
    peg$literalExpectation("_", false),
    peg$literalExpectation("\xB7", false),
    peg$classExpectation([["\u0300", "\u036F"]], false, false),
    peg$classExpectation([["\u203F", "\u2040"]], false, false),
    peg$literalExpectation("%", false),
    peg$classExpectation([["A", "F"]], false, false),
    peg$classExpectation([["a", "f"]], false, false),
    peg$literalExpectation("~", false),
    peg$literalExpectation("!", false),
    peg$literalExpectation("$", false),
    peg$literalExpectation("&", false),
    peg$literalExpectation("*", false),
    peg$literalExpectation("+", false),
    peg$literalExpectation("=", false),
    peg$literalExpectation("/", false),
    peg$literalExpectation("?", false),
    peg$literalExpectation("#", false),
    peg$classExpectation(["\r", "\n"], true, false),
    peg$classExpectation(["\r", "\n"], false, false)
  ];
  var peg$functions = [
    function(chunk) {
            var currentContext = {}, currentGraph = [];
            var result = [
                {'@context': currentContext, '@graph': currentGraph}
            ];
            var vocab = '';

            function cleanupPNameTags(item, vocab) {
                var id = item['@id'];
                if (item[PNAME_TAG]) {
                    delete item[PNAME_TAG];
                    if (id === null) {
                        item['@id'] = vocab;
                    } else if (id.indexOf(':') === -1) {
                        item['@id'] = vocab + id;
                    }
                }
                for (var key in item) {
                    var o = item[key];
                    if (typeof o === 'object') {
                        cleanupPNameTags(o, vocab);
                    }
                }
            }

            for (let [item, ws] of chunk) {
                var ctxItem = item['@context'];
                if (ctxItem) {
                    if (currentGraph.length !== 0) {
                        currentContext = {};
                        currentGraph = [];
                        result.push(
                            {'@context': currentContext, '@graph': currentGraph}
                        );
                    }
                    assign(currentContext, ctxItem);
                    vocab = currentContext['@vocab'] || '';

                    delete item['@context'];
                    if (isEmptyObject(item)) {
                        continue
                    }
                }

                if (Array.isArray(item)) {
                    currentGraph.push.apply(currentGraph, item);
                } else {
                    cleanupPNameTags(item, vocab);
                    currentGraph.push(item);
                }
            }
            return result.length === 1? result[0] : result;
        },
    function(g) { return g['@graph']; },
    function(name, wg) {
            return assign(name, wg);
        },
    function(subject, pos) { return pos; },
    function(subject, labelled) {
            if (typeof labelled['@graph'] !== 'undefined') {
                return assign(subject, labelled);
            } else {
                return reducePairs(subject, labelled);
            }
        },
    function(quoted, pos) {
            return reducePairs(quoted, pos)
        },
    function(bnpairs, pos) {
            return pos? reducePairs(bnpairs, pos) : bnpairs;
        },
    function(collection, pos) {
            return pos? reducePairs(collection, pos) : collection;
        },
    function(tb) {
            return {'@graph': tb};
        },
    function(triples, block) { return block; },
    function(triples, next) {
            var items = [triples];
            if (next) {
                items.push.apply(items, next);
            }
            return items;
        },
    function(pfx, iriref) {
            return prefix(pfx, iriref);
        },
    function(iriref) {
            return base(iriref);
        },
    function(subject, pos) {
            return reducePairs(subject, pos);
        },
    function(verb, objectList, vol) { return vol; },
    function(verb, objectList, rest) {
            var po = toPair(verb, objectList);
            var pairs = [po];
            for (var pair of rest) {
                if (pair === null) // last ';', so we could also break
                    continue
                let [rTerm, rList] = pair;
                po = toPair(rTerm, rList);
                pairs.push(po);
            }
            return pairs;
        },
    function(object, annotation) { return packAnnotation(object, annotation) },
    function(first, object, annotation) { return packAnnotation(object, annotation) },
    function(first, annotated) { return annotated },
    function(first, remainder) {
            if (remainder.length > 0) {
                var objects = [first];
                for (var annotated of remainder) {
                    objects.push(annotated);
                }
                return objects;
            } else {
                return first;
            }
        },
    function() {return TYPE; },
    function(verb) {
            return typeof verb === 'object' ? verb['@id'] || '' : verb;
        },
    function(literal) {
            return literal;
        },
    function(pos) {
            return reducePairs({}, pos);
        },
    function(collection) {
            return {'@list': collection};
        },
    function(s, p, o) {
        let obj = reducePairs(s, [toPair(p, o)])
        return { '@id': obj }
    },
    function(rdfliteral, datatype) { return {[TYPE]: datatype['@id']}; },
    function(rdfliteral, tag) {
            var value = rdfliteral;
            if (tag !== null) {
                value = {'@value': rdfliteral};
                assign(value, tag);
            }
            return value;
        },
    function() { return true; },
    function() { return false; },
    function(value) {
            return value;
        },
    function(iri) {
            return iri;
        },
    function(pname) {
        var item = {"@id": pname};
        item[PNAME_TAG] = true;
        return item;
    },
    function(bnode) {
            return bnode;
        },
    function(iriref) {
            return {"@id": iriref.join('')};
        },
    function(pfx) {
            return pfx;
        },
    function(ns, l) {
            return (ns === null? '' : ns + ':') + l;
        },
    function(lead, first, chars) { return chars.join(''); },
    function(lead, first, rest) {
            var label = first + (rest? rest.join('') : '');
            return {'@id': lead + label};
        },
    function(tag, subtag) {
            var sub = (subtag.length? subtag.map(function (it) {
                return it[0] + it[1].join(''); }).join('') : '');
            return {"@language": tag.join('') + sub};
        },
    function(sign, digits) {
            var i = parseInt(digits.join(''), 10);
            if (sign === '-')
                i = -1 * i;
            return i;
        },
    function(sign, whole, fraction) {
                return (whole? whole.join('') : '') + '.' + fraction.join('');
            },
    function(sign, digits) {
            return parseFloat((sign || '') + digits, 10);
        },
    function(sign, whole, fraction, exp) {
                return whole.join('') + '.' +
                    (fraction? fraction.join('') : '') + exp;
            },
    function(sign, fraction, exp) {
                return fraction.join('') + exp;
            },
    function(sign, whole, exp) {
                return whole.join('') + exp;
            },
    function(e, sign, digits) {
            return e + (sign || '') + digits.join('');
        },
    function(value) {
            return value.join('');
        },
    function(first, rest) { return (first || '') + rest; },
    function(hex) {
            return String.fromCharCode(parseInt(hex.join(''), 16));
        },
    function(chr) {
            return echars[chr];
        },
    function() { return {}; },
    function(first, chars) { return chars.join(''); },
    function(first, rest) {
            return first + (rest? rest.join('') : '');
        },
    function(a, b) { return '%' + a + b; },
    function(chr) {
            return chr;
        }
  ];

  var peg$bytecode = [
    peg$decode("%;\\$%;'.# &;!/%#;\\+\")&'#05*%;'.# &;!/%#;\\+\")&'#&8\": #! "),
    peg$decode(";\".f &%;$/' 8!:!!! ).T &;#.N &%;\\7 3 \"!5%#/:$;&/1$;$/($8$:\"%\"! ($'#(#'#(\"'#"),
    peg$decode("%;&/X#;$.D &%;-/:#;\\7!2!\"!6!#/($8#:#$\"$\"(#'#&'#/($8\":$#\"! (\"'#&'#.O &%;6/E#;\\;-/:$;\\7!2!\"!6!#/($8%:%&\"$\"(%'#(#'#&'#"),
    peg$decode("%;4/A#;-.\" &\";\\7!2!\"!6!#/($8$:&%\"#\"($'#&'#.M &%;5/C#;-/:$;\\7!2!\"!6!#/($8$:'%\"#\"($'#(\"'#&'#"),
    peg$decode("%;\\7\"2\"\"!6\"#/B$;%.\" &\";\\7#2#\"!6##/)$;\\8&:('!#(%'#(\"'#"),
    peg$decode("%;,/L#%7!2!\"!6!#//#;%.\" &\"8\":)#\"# &'#.\" &\"8\":*#\"! &'#"),
    peg$decode(";>.# &;@"),
    peg$decode(";(./ &;).) &;*.# &;+"),
    peg$decode("%7$2$\"!6$#/R#;\\;B/G$;\\;A/<$;\\7!2!\"!6!#/*$;\\8(:+)\"%#(''#(%'#(#'#&'#"),
    peg$decode("%7%2%\"!6%#/F#;\\;A/;$;\\7!2!\"!6!#/)$;\\8&:,'!#(%'#(#'#&'#"),
    peg$decode("%7&3&\"!5&#/@#;\\;B/5$;\\;A/*$;\\8&:+'\"#!(%'#(#'#&'#"),
    peg$decode("%7'3'\"!5$#/4#;\\;A/)$;\\8$:,%!!(#'#&'#"),
    peg$decode("%;0/1#;-/($8\":-#\"! (\"'#&'#.4 &%;4/*#;-.\" &\"+\")&'#"),
    peg$decode("%;//\x9F#;./\x96$$%7(2(\"!6(#/C#%;//,#;./#$+\")(\"'#&'#.\" &\"8\":.##%$ &'#0T*%7(2(\"!6(#/C#%;//,#;./#$+\")(\"'#&'#.\" &\"8\":.##%$ &'#&;\\8$:/%##\"!(\"'#&'#"),
    peg$decode("%%;1/1#;\\;9.\" &\"8#:0$\"\" &'#/\xAB#$%;\\7)2)\"!6)#/L$;\\%;1/2#;\\;9.\" &\"8#:1$#)\" &'#/($8$:2%\"& ($'#(\"'#0`*%;\\7)2)\"!6)#/L$;\\%;1/2#;\\;9.\" &\"8#:1$#)\" &'#/($8$:2%\"& ($'#(\"'#&8\":3#\"! &'#"),
peg$decode("%;\\;>.5 &%7*2*\"!6*#/& 8!:4! )/)$;\\8#:5$!!(\"'#"),
peg$decode(";>.) &;3.# &;6"),
peg$decode(";>.5 &;3./ &;4.) &;2.# &;6"),
peg$decode("%;\\;;.) &;:.# &;</)$;\\8#:6$!!(\"'#"),
peg$decode(";@.# &;5"),
peg$decode("%;\\7+2+\"!6+#/B$;-/9$7,2,\"!6,#/)$;\\8%:7&!\"($'#(#'#(\"'#"),
peg$decode("%;\\7-2-\"!6-#/F$;\\$;10#*;1&;\\7.2.\"!6.#/)$;\\8':8(!#(&'#(\"'#"),
peg$decode("%;\\7/2/\"!6/#/^$;\\;7/S$;\\;//H$;\\;8/=$;\\7020\"!60#/+$;\\8+:9,#'%#(*'#(('#(&'#($'#(\"'#"),
peg$decode(";>.) &;@.# &;6"),
peg$decode(";>./ &;@.) &;2.# &;6"),
peg$decode("%;\\7121\"!61#/B$;-/9$7222\"!62#/)$;\\8%:7&!\"($'#(#'#(\"'#"),
peg$decode(";H.) &;G.# &;F"),
peg$decode("%;=/T#;E.B &%7323\"!63#/1#;>/($8\"::#\"# (\"'#&'#.\" &\"8\":;#\"! &'#"),
peg$decode("%7424\"!64#/& 8!:<! ).5 &%7525\"!65#/& 8!:=! )"),
peg$decode("%;\\;L./ &;M.) &;J.# &;K/)$;\\8#:>$!!(\"'#"),
peg$decode("%;\\;A.# &;?/)$;\\8#:?$!!(\"'#"),
peg$decode("%;C.# &;B/' 8!:@!! )"),
peg$decode("%;\\;D.# &;R/)$;\\8#:A$!!(\"'#"),
peg$decode("%7626\"!66#/Z#$774 \"!5!#.# &;N00*774 \"!5!#.# &;N&7827\"!67#/'$8#:B$!!(#'#&'#"),
peg$decode("%;V.\" &\"7928\"!68#/'$8\":C#!!(\"'#"),
peg$decode("%;B/1#;W/($8\":D#\"! (\"'#&'#"),
peg$decode("%7:29\"!69#/\xA4#;T.* &7;4!\"!5!#/\x8E$$%%7!2!\"!6!#/,#;U/#$+\")(\"'#&'#/) 8!:E!#$# ).# &;U0Q*%%7!2!\"!6!#/,#;U/#$+\")(\"'#&'#/) 8!:E!#$# ).# &;U&8#:F$#\"! (\"'#&'#"),
peg$decode("%7<2:\"!6:#/\xBF#$7=4\"\"!5!#/-#0**7=4\"\"!5!#&&&#/\x9B$$%7>2;\"!6;#/G#$7?4#\"!5!#/-#0**7?4#\"!5!#&&&#/#$+\")(\"'#&'#0X*%7>2;\"!6;#/G#$7?4#\"!5!#/-#0**7?4#\"!5!#&&&#/#$+\")(\"'#&'#&8#:G$\"! (\"'#&'#"),
peg$decode("%7@4$\"!5!#.\" &\"$7;4!\"!5!#/-#0**7;4!\"!5!#&&&#/($8\":H#\"! (\"'#"),
peg$decode("%7@4$\"!5!#.\" &\"%$7;4!\"!5!#0**7;4!\"!5!#&7!2!\"!6!#/M$$7;4!\"!5!#/-#0**7;4!\"!5!#&&&#/)$8#:I$#$\" (#'#(\"'#/($8\":J#\"! (\"'#"),
peg$decode("%7@4$\"!5!#.\" &\"%$7;4!\"!5!#/-#0**7;4!\"!5!#&&&#/Z#7!2!\"!6!#/J$$7;4!\"!5!#0**7;4!\"!5!#&;I/*$8$:K%$%#! ($'#(\"'#&'#.\xA1 &%7!2!\"!6!#/V#$7;4!\"!5!#/-#0**7;4!\"!5!#&&&#/2$;I/)$8#:L$#$! (#'#(\"'#&'#.W &%$7;4!\"!5!#/-#0**7;4!\"!5!#&&&#/2#;I/)$8\":M###! (\"'#&'#/($8\":J#\"! (\"'#"),
peg$decode("%7A4%\"!5!#/[#7@4$\"!5!#.\" &\"$7;4!\"!5!#/-#0**7;4!\"!5!#&&&#/)$8#:N$#\"! (#'#&'#"),
peg$decode("%7B2<\"!6<#/f#$7C4&\"!5!#.) &;O.# &;N06*7C4&\"!5!#.) &;O.# &;N&7B2<\"!6<#/'$8#:O$!!(#'#&'#"),
peg$decode("%7D2=\"!6=#/f#$7E4'\"!5!#.) &;O.# &;N06*7E4'\"!5!#.) &;O.# &;N&7D2=\"!6=#/'$8#:O$!!(#'#&'#"),
peg$decode("%7F2>\"!6>#/\xBC#$%7D2=\"!6=#.* &7G2?\"!6?#.\" &\"7H4(\"!5!#.) &;O.# &;N/($8\":P#\"! (\"'#0a*%7D2=\"!6=#.* &7G2?\"!6?#.\" &\"7H4(\"!5!#.) &;O.# &;N/($8\":P#\"! (\"'#&7F2>\"!6>#/'$8#:O$!!(#'#&'#"),
peg$decode("%7I2@\"!6@#/\xBC#$%7B2<\"!6<#.* &7J2A\"!6A#.\" &\"7K4)\"!5!#.) &;O.# &;N/($8\":P#\"! (\"'#0a*%7B2<\"!6<#.* &7J2A\"!6A#.\" &\"7K4)\"!5!#.) &;O.# &;N/($8\":P#\"! (\"'#&7I2@\"!6@#/'$8#:O$!!(#'#&'#"),
peg$decode("%7L2B\"!6B#/U#%;Z/>#;Z/5$;Z/,$;Z/#$+$)($'#(#'#(\"'#&'#/'$8\":Q#! (\"'#&'#.\x8A &%7M2C\"!6C#/y#%;Z/b#;Z/Y$;Z/P$;Z/G$;Z/>$;Z/5$;Z/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/'$8\":Q#! (\"'#&'#"),
peg$decode("%7N2D\"!6D#/7#7O4*\"!5!#/'$8\":R#! (\"'#&'#"),
peg$decode("%2-\"!6-#/3#;\\2.\"!6.#/#$+#)(#'#&'#"),
peg$decode("7P2E\"!6E#.D &7Q2F\"!6F#.7 &7R2G\"!6G#.* &7S2H\"!6H#"),
peg$decode("%7+2+\"!6+#/8#;\\7,2,\"!6,#/&$8#:S$ (#'#&'#"),
peg$decode("7T4+\"!5!#.\xB9 &7U4,\"!5!#.\xAC &7V4-\"!5!#.\x9F &7W4.\"!5!#.\x92 &7X4/\"!5!#.\x85 &7Y40\"!5!#.x &7Z41\"!5!#.k &7[42\"!5!#.^ &7\\43\"!5!#.Q &7]44\"!5!#.D &7^45\"!5!#.7 &7_46\"!5!#.* &7`47\"!5!#"),
    peg$decode(";S.* &7a2I\"!6I#"),
    peg$decode(";T.^ &7>2;\"!6;#.Q &7;4!\"!5!#.D &7b2J\"!6J#.7 &7c48\"!5!#.* &7d49\"!5!#"),
    peg$decode("%;S/\x8B#$%%7!2!\"!6!#/,#;U/#$+\")(\"'#&'#/( 8!:T!\"# ).# &;U0P*%%7!2!\"!6!#/,#;U/#$+\")(\"'#&'#/( 8!:T!\"# ).# &;U&8\":U#\"! &'#"),
    peg$decode("%;T.= &7928\"!68#.0 &7;4!\"!5!#.# &;X/\u0109#$%%;U.= &7!2!\"!6!#.0 &7928\"!68#.# &;X/?#;U.0 &7928\"!68#.# &;X/#$+\")(\"'#&'#/( 8!:T!\"# ).6 &;U.0 &7928\"!68#.# &;X0\x8F*%%;U.= &7!2!\"!6!#.0 &7928\"!68#.# &;X/?#;U.0 &7928\"!68#.# &;X/#$+\")(\"'#&'#/( 8!:T!\"# ).6 &;U.0 &7928\"!68#.# &;X&8\":U#\"! &'#"),
    peg$decode(";Y.# &;["),
    peg$decode("%7e2K\"!6K#/:#;Z/1$;Z/($8#:V$\"! (#'#(\"'#&'#"),
    peg$decode("7;4!\"!5!#.7 &7f4:\"!5!#.* &7g4;\"!5!#"),
    peg$decode("%7N2D\"!6D#/\u012E#7a2I\"!6I#.\u0114 &7h2L\"!6L#.\u0107 &7!2!\"!6!#.\xFA &7>2;\"!6;#.\xED &7i2M\"!6M#.\xE0 &7j2N\"!6N#.\xD3 &7k2O\"!6O#.\xC6 &7D2=\"!6=#.\xB9 &7-2-\"!6-#.\xAC &7.2.\"!6.#.\x9F &7l2P\"!6P#.\x92 &7m2Q\"!6Q#.\x85 &7)2)\"!6)#.x &7(2(\"!6(#.k &7n2R\"!6R#.^ &7o2S\"!6S#.Q &7p2T\"!6T#.D &7q2U\"!6U#.7 &7<2:\"!6:#.* &7e2K\"!6K#/'$8\":W#! (\"'#&'#"),
    peg$decode("$;Q.[ &%7q2U\"!6U#/J#$7r4<\"!5!#0**7r4<\"!5!#&7s4=\"!5!#/#$+#)(#'#&'#0a*;Q.[ &%7q2U\"!6U#/J#$7r4<\"!5!#0**7r4<\"!5!#&7s4=\"!5!#/#$+#)(#'#&'#&")
  ];

  var peg$currPos = 0;
  var peg$savedPos = 0;
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
  var peg$expected = [];
  var peg$silentFails = 0;

  var peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function offset() {
    return peg$savedPos;
  }

  function range() {
    return [peg$savedPos, peg$currPos];
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  var peg$VALIDFILENAME = typeof options.filename === "string" && options.filename.length > 0;
  function peg$computeLocation(startPos, endPos) {
    var loc = {};

    if ( peg$VALIDFILENAME ) loc.filename = options.filename;

    var startPosDetails = peg$computePosDetails(startPos);
    loc.start = {
      offset: startPos,
      line: startPosDetails.line,
      column: startPosDetails.column
    };

    var endPosDetails = peg$computePosDetails(endPos);
    loc.end = {
      offset: endPos,
      line: endPosDetails.line,
      column: endPosDetails.column
    };

    return loc;
  }

  function peg$begin() {
    peg$expected.push({ pos: peg$currPos, variants: [] });
  }

  function peg$expect(expected) {
    var top = peg$expected[peg$expected.length - 1];

    if (peg$currPos < top.pos) { return; }

    if (peg$currPos > top.pos) {
      top.pos = peg$currPos;
      top.variants = [];
    }

    top.variants.push(expected);
  }

  function peg$end(invert) {
    var expected = peg$expected.pop();
    var top = peg$expected[peg$expected.length - 1];
    var variants = expected.variants;

    if (top.pos !== expected.pos) { return; }

    if (invert) {
      variants = variants.map(function(e) {
        return e.type === "not" ? e.expected : { type: "not", expected: e };
      });
    }

    Array.prototype.push.apply(top.variants, variants);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$buildError() {
    var expected = peg$expected[0];
    var failPos = expected.pos;

    return peg$buildStructuredError(
      expected.variants,
      failPos < input.length ? input.charAt(failPos) : null,
      failPos < input.length
        ? peg$computeLocation(failPos, failPos + 1)
        : peg$computeLocation(failPos, failPos)
    );
  }

  function peg$decode(s) {
    return s.split("").map(function(ch) { return ch.charCodeAt(0) - 32; });
  }

  function peg$parseRule(index) {
    var bc = peg$bytecode[index];
    var ip = 0;
    var ips = [];
    var end = bc.length;
    var ends = [];
    var stack = [];
    var params, paramsLength, paramsN;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push('');
            ip++;
            break;

          case 1:
            stack.push(undefined);
            ip++;
            break;

          case 2:
            stack.push(null);
            ip++;
            break;

          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;

          case 4:
            stack.push([]);
            ip++;
            break;

          case 5:
            stack.push(peg$currPos);
            ip++;
            break;

          case 6:
            stack.pop();
            ip++;
            break;

          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;

          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;

          case 9:
            stack.splice(-2, 1);
            ip++;
            break;

          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;

          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;

          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;

          case 41:
            paramsLength = bc[ip + 2];
            paramsN = 3 + paramsLength

            params = bc.slice(ip + 3, ip + paramsN);
            params = paramsLength === 1
              ? stack[stack.length - 1 - params[ 0 ]]
              : params.map(function(p) { return stack[stack.length - 1 - p]; });

            stack.splice(
              stack.length - bc[ip + 1],
              bc[ip + 1],
              params
            );

            ip += paramsN;
            break;

          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);

              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }

            break;

          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$literals[bc[ip + 1]].length) === peg$literals[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$literals[bc[ip + 1]].length).toLowerCase() === peg$literals[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (peg$regexps[bc[ip + 1]].test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;

          case 22:
            stack.push(peg$literals[bc[ip + 1]]);
            peg$currPos += peg$literals[bc[ip + 1]].length;
            ip += 2;
            break;

          case 23:
            rule$expects(peg$expectations[bc[ip + 1]]);
            ip += 2;
            break;

          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;

          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;

          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
              .map(function(p) { return stack[stack.length - 1 - p]; });

            stack.splice(
              stack.length - bc[ip + 2],
              bc[ip + 2],
              peg$functions[bc[ip + 1]].apply(null, params)
            );

            ip += 4 + bc[ip + 3];
            break;

          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;

          case 28:
            peg$silentFails++;
            ip++;
            break;

          case 29:
            peg$silentFails--;
            ip++;
            break;

          case 38:
            peg$begin();
            ip++;
            break;

          case 39:
            peg$end(bc[ip + 1]);
            ip += 2;
            break;

          // istanbul ignore next
          default:
            throw new Error(
              "Rule #" + index + ", position " + ip + ": "
              + "Invalid opcode " + bc[ip] + "."
            );
        }
      }

      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }

    return stack[0];
  }



      const PNAME_TAG = "_:neverspace.net,2016-01-10:ldtr:pname";

      const TYPE = '@type';
      const ANNOTATION = '@annotation';
      const ANNOTATED_TYPE_KEY = '@set'; // TYPE // '@index'
      const TYPEANNOTATION = null;//'@type@annotation';
      const KEEP_REDUNDANT_ANNOTATED_TYPE = false; // true;
      const TYPEANNOTATION_DECL = {
          [TYPEANNOTATION]: {
              "@id": TYPE,
              "@container": "@annotation"
          }
      };
      //const ANNOTATED_OBJECTS_KEY = '@object';

      const TRIPLE_KEY = '@id';

      function assign(target, source) {
          for (var key in source) {
              target[key] = source[key];
          }
          return target;
      }

      function isEmptyObject(o) {
          for (let k in o) {
              if (o.hasOwnProperty(k)) return false;
          }
          return true;
      }

      function contextItem(key, value) {
          var decl = {}
          decl[key] = value;
          return {'@context': decl};
      }

      function prefix(pfx, iriref) {
          return contextItem(pfx || '@vocab', iriref['@id']);
      }

      function base(iriref) {
          return contextItem('@base', iriref['@id']);
      }

      function toPair(verb, objectList) {
          if (verb === TYPE) return toTypePair(objectList);

          var po = {};
          po[verb] = objectList;
          return po;
      }

      function toTypePair(objectList) {
          function reducePname(o) {
              if (typeof o === 'object') {
                  /*
                  if (ANNOTATED_OBJECTS_KEY &&
                      ANNOTATED_OBJECTS_KEY in o &&
                      '@id' in o[ANNOTATED_OBJECTS_KEY]) {
                      o[ANNOTATED_OBJECTS_KEY] = o[ANNOTATED_OBJECTS_KEY]['@id']
                  } else
                  */
                  if ('@id' in o) {
                      if (ANNOTATION in o) {
                          o = {
                              [ANNOTATED_TYPE_KEY]: o['@id'],
                              [ANNOTATION]: o[ANNOTATION]
                          }
                      } else {
                          o = o['@id']
                      }
                  }
                  // TODO: if value is an actual (b)node object, item need to use
                  // rdf:type as key for those values instead of @type.
              }
              return o
          }

          let isObjectArray = Array.isArray(objectList)
          if (!isObjectArray) {
              objectList = [objectList]
          }

          let plain = [];
          let annotated = {};
          let anyannot = false;

          for (let o of objectList) {
              let reduced = reducePname(o);
              if (typeof reduced === 'object' && TYPEANNOTATION) {
                  anyannot = true;
                  let typevalue = reduced[ANNOTATED_TYPE_KEY];
                  annotated[typevalue] = reduced[ANNOTATION];
                  if (KEEP_REDUNDANT_ANNOTATED_TYPE) {
                      plain.push(typevalue);
                  }
              } else {
                  plain.push(reduced);
              }
          }

          let typepair = {};
          if (plain.length > 0) {
              typepair[TYPE] = !isObjectArray ? plain[0] : plain;
          }
          if (anyannot) {
              typepair['@context'] = TYPEANNOTATION_DECL
              typepair[TYPEANNOTATION] = annotated;
          }

          return typepair;
      }

      function reducePairs(subject, pairs) {
          if (subject === null) {
              subject = '';
          }
          if (typeof subject === 'string') {
              if (subject.indexOf(':') === -1) {
                  subject = ':' + subject;
              }
              subject = {'@id': subject};
          }
          for (var pair of pairs) {
              for (var key in pair) {
                  var value = pair[key];
                  var existing = subject[key];
                  if (typeof existing !== 'undefined') {
                      if (!Array.isArray(existing)) {
                          existing = [existing];
                      }
                      if (Array.isArray(value)) {
                          existing = existing.concat(value);
                      } else {
                          existing.push(value);
                      }
                      value = existing;
                  }
                  subject[key] = value;
              }
          }
          return subject;
      }

      function packAnnotation (object, annotation) {
          if (annotation == null) {
              return object
          }
          /*
          if (ANNOTATED_OBJECTS_KEY) {
              annotation[ANNOTATED_OBJECTS_KEY] = object
              return annotation
          }
          */
          if (typeof object !== 'object') {
              object = {'@value': object, [ANNOTATION]: annotation}
          } else {
              object[ANNOTATION] = annotation
          }
          return object
      }

      var echars = {
          t: '\t',
          b: '\b',
          n: '\n',
          r: '\r',
          f: '\f',
          '"': '"',
          "'": "'",
          '\\': '\\'
      };



  peg$begin();
  peg$result = peg$parseRule(peg$startRuleIndex);

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$expect(peg$endExpectation());
    }

    throw peg$buildError();
  }
}

export {
  peg$SyntaxError as SyntaxError,
  peg$parse as parse
};

export default {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse
};
