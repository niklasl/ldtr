// Generated by PEG.js v0.11.0-master.f69239d, https://pegjs.org/

function peg$subclass(child, parent) {
  function C() { this.constructor = child; }
  C.prototype = parent.prototype;
  child.prototype = new C();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  // istanbul ignore next
  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },

    class: function(expectation) {
      var escapedParts = expectation.parts.map(function(part) {
        return Array.isArray(part)
          ? classEscape(part[0]) + "-" + classEscape(part[1])
          : classEscape(part);
      });

      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },

    any: function() {
      return "any character";
    },

    end: function() {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    },

    not: function(expectation) {
      return "not " + describeExpectation(expectation.expected);
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/"/g,  "\\\"")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/\]/g, "\\]")
      .replace(/\^/g, "\\^")
      .replace(/-/g,  "\\-")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = expected.map(describeExpectation);
    var i, j;

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== undefined ? options : {};

  var peg$FAILED = {};

  var peg$startRuleIndices = { trigDoc: 0 };
  var peg$startRuleIndex = 0;

  var peg$literals = [
    "graph",
    ".",
    "{",
    "}",
    "@prefix",
    "@base",
    "prefix",
    "base",
    ";",
    ",",
    "a",
    "[",
    "]",
    "(",
    ")",
    "^^",
    "true",
    "false",
    "<",
    ">",
    ":",
    "_:",
    "@",
    "-",
    "\"",
    "'",
    "'''",
    "''",
    "\"\"\"",
    "\"\"",
    "\\u",
    "\\U",
    "\\",
    " ",
    "\t",
    "\r",
    "\n",
    "_",
    "\xB7",
    "%",
    "~",
    "!",
    "$",
    "&",
    "*",
    "+",
    "=",
    "/",
    "?",
    "#"
  ];
  var peg$regexps = [
  /^[^\0- <>"{}|\^`\\]/,
  /^[0-9]/,
  /^[a-zA-Z]/,
  /^[a-zA-Z0-9]/,
  /^[+\-]/,
  /^[eE]/,
  /^[^"\\\n\r]/,
  /^[^'\\\n\r]/,
  /^[^'\\]/,
  /^[^"\\]/,
  /^[tbnrf"'\\]/,
  /^[A-Z]/,
  /^[a-z]/,
  /^[\xC0-\xD6]/,
  /^[\xD8-\xF6]/,
  /^[\xF8-\u02FF]/,
  /^[\u0370-\u037D]/,
  /^[\u037F-\u1FFF]/,
  /^[\u200C-\u200D]/,
  /^[\u2070-\u218F]/,
  /^[\u2C00-\u2FEF]/,
  /^[\u3001-\uD7FF]/,
  /^[\uF900-\uFDCF]/,
  /^[\uFDF0-\uFFFD]/,
  /^[\u0300-\u036F]/,
  /^[\u203F-\u2040]/,
  /^[A-F]/,
  /^[a-f]/,
  /^[^\r\n]/,
  /^[\r\n]/
];
var peg$expectations = [
  peg$literalExpectation("GRAPH", true),
  peg$literalExpectation(".", false),
  peg$literalExpectation("{", false),
  peg$literalExpectation("}", false),
  peg$literalExpectation("@prefix", false),
  peg$literalExpectation("@base", false),
  peg$literalExpectation("PREFIX", true),
  peg$literalExpectation("BASE", true),
  peg$literalExpectation(";", false),
  peg$literalExpectation(",", false),
  peg$literalExpectation("a", false),
  peg$literalExpectation("[", false),
  peg$literalExpectation("]", false),
  peg$literalExpectation("(", false),
  peg$literalExpectation(")", false),
  peg$literalExpectation("^^", false),
  peg$literalExpectation("true", false),
  peg$literalExpectation("false", false),
  peg$literalExpectation("<", false),
peg$classExpectation([["\0", " "], "<", ">", "\"", "{", "}", "|", "^", "`", "\\"], true, false),
    peg$literalExpectation(">", false),
    peg$literalExpectation(":", false),
    peg$literalExpectation("_:", false),
    peg$classExpectation([["0", "9"]], false, false),
    peg$literalExpectation("@", false),
    peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
    peg$literalExpectation("-", false),
    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
    peg$classExpectation(["+", "-"], false, false),
    peg$classExpectation(["e", "E"], false, false),
    peg$literalExpectation("\"", false),
    peg$classExpectation(["\"", "\\", "\n", "\r"], true, false),
    peg$literalExpectation("'", false),
    peg$classExpectation(["'", "\\", "\n", "\r"], true, false),
    peg$literalExpectation("'''", false),
    peg$literalExpectation("''", false),
    peg$classExpectation(["'", "\\"], true, false),
    peg$literalExpectation("\"\"\"", false),
    peg$literalExpectation("\"\"", false),
    peg$classExpectation(["\"", "\\"], true, false),
    peg$literalExpectation("\\u", false),
    peg$literalExpectation("\\U", false),
    peg$literalExpectation("\\", false),
    peg$classExpectation(["t", "b", "n", "r", "f", "\"", "'", "\\"], false, false),
    peg$literalExpectation(" ", false),
    peg$literalExpectation("\t", false),
    peg$literalExpectation("\r", false),
    peg$literalExpectation("\n", false),
    peg$classExpectation([["A", "Z"]], false, false),
    peg$classExpectation([["a", "z"]], false, false),
    peg$classExpectation([["\xC0", "\xD6"]], false, false),
    peg$classExpectation([["\xD8", "\xF6"]], false, false),
    peg$classExpectation([["\xF8", "\u02FF"]], false, false),
    peg$classExpectation([["\u0370", "\u037D"]], false, false),
    peg$classExpectation([["\u037F", "\u1FFF"]], false, false),
    peg$classExpectation([["\u200C", "\u200D"]], false, false),
    peg$classExpectation([["\u2070", "\u218F"]], false, false),
    peg$classExpectation([["\u2C00", "\u2FEF"]], false, false),
    peg$classExpectation([["\u3001", "\uD7FF"]], false, false),
    peg$classExpectation([["\uF900", "\uFDCF"]], false, false),
    peg$classExpectation([["\uFDF0", "\uFFFD"]], false, false),
    peg$literalExpectation("_", false),
    peg$literalExpectation("\xB7", false),
    peg$classExpectation([["\u0300", "\u036F"]], false, false),
    peg$classExpectation([["\u203F", "\u2040"]], false, false),
    peg$literalExpectation("%", false),
    peg$classExpectation([["A", "F"]], false, false),
    peg$classExpectation([["a", "f"]], false, false),
    peg$literalExpectation("~", false),
    peg$literalExpectation("!", false),
    peg$literalExpectation("$", false),
    peg$literalExpectation("&", false),
    peg$literalExpectation("*", false),
    peg$literalExpectation("+", false),
    peg$literalExpectation("=", false),
    peg$literalExpectation("/", false),
    peg$literalExpectation("?", false),
    peg$literalExpectation("#", false),
    peg$classExpectation(["\r", "\n"], true, false),
    peg$classExpectation(["\r", "\n"], false, false)
  ];
  var peg$functions = [
    function(data) {
            var currentContext = {}, currentGraph = [];
            var result = [
                {'@context': currentContext, '@graph': currentGraph}
            ];
            var vocab = '';

            function cleanupPNameTags(item, vocab) {
                var id = item['@id'];
                if (item[PNAME_TAG]) {
                    delete item[PNAME_TAG];
                    if (id === null) {
                        item['@id'] = vocab;
                    } else if (id.indexOf(':') === -1) {
                        item['@id'] = vocab + id;
                    }
                }
                for (var key in item) {
                    var o = item[key];
                    if (typeof o === 'object') {
                        cleanupPNameTags(o, vocab);
                    }
                }
            }

            for (var item of data) {
                var ctxItem = item['@context'];
                if (ctxItem) {
                    if (currentGraph.length !== 0) {
                        currentContext = {};
                        currentGraph = [];
                        result.push(
                            {'@context': currentContext, '@graph': currentGraph}
                        );
                    }
                    assign(currentContext, ctxItem);
                    vocab = currentContext['@vocab'] || '';
                } else if (Array.isArray(item)) {
                    currentGraph.push.apply(currentGraph, item);
                } else {
                    cleanupPNameTags(item, vocab);
                    currentGraph.push(item);
                }
            }
            return result.length === 1? result[0] : result;
        },
    function(g) { return g['@graph']; },
    function(name, wg) {
            return assign(name, wg);
        },
    function(subject, pos) { return pos; },
    function(subject, labelled) {
            if (typeof labelled['@graph'] !== 'undefined') {
                return assign(subject, labelled);
            } else {
                return reducePairs(subject, labelled);
            }
        },
    function(bnpairs, pos) {
            return pos? reducePairs(bnpairs, pos) : bnpairs;
        },
    function(collection, pos) {
            return pos? reducePairs(bnpairs, pos) : bnpairs;
        },
    function(tb) {
            return {'@graph': tb};
        },
    function(triples, block) { return block; },
    function(triples, next) {
            var items = [triples];
            if (next) {
                items.push.apply(items, next);
            }
            return items;
        },
    function(pfx, iriref) {
            return prefix(pfx, iriref);
        },
    function(iriref) {
            return base(iriref);
        },
    function(subject, pos) {
            return reducePairs(subject, pos);
        },
    function(verb, objectList, vol) { return vol; },
    function(verb, objectList, rest) {
            if (verb === '@type') {
                objectList = toSymbols(objectList);
            }
            var po = toPair(verb, objectList);
            var pairs = [po];
            for (var pair of rest) {
                if (pair === null) // last ';', so we could also break
                    continue
                var restList = pair[1];
                if (pair[0] === '@type') {
                    restList = toSymbols(restList);
                }
                po = toPair(pair[0], restList);
                pairs.push(po);
            }
            return pairs;
        },
    function(first, object) { return object; },
    function(first, remainder) {
            if (remainder.length > 0) {
                var objects = [first];
                for (var object of remainder) {
                    objects.push(object);
                }
                return objects;
            } else {
                return first;
            }
        },
    function() {return '@type'; },
    function(verb) {
            return typeof verb === 'object' ? verb['@id'] || '' : verb;
        },
    function(literal) {
            return literal;
        },
    function(pos) {
            return reducePairs({}, pos);
        },
    function(collection) {
            return {'@list': collection};
        },
    function(rdfliteral, datatype) { return {'@type': datatype['@id']}; },
    function(rdfliteral, tag) {
            var value = rdfliteral;
            if (tag !== null) {
                value = {'@value': rdfliteral};
                assign(value, tag);
            }
            return value;
        },
    function() { return true; },
    function() { return false; },
    function(value) {
            return value;
        },
    function(iri) {
            return iri;
        },
    function(pname) {
        var item = {"@id": pname};
        item[PNAME_TAG] = true;
        return item;
    },
    function(bnode) {
            return bnode;
        },
    function(iriref) {
            return {"@id": iriref.join('')};
        },
    function(pfx) {
            return pfx;
        },
    function(ns, l) {
            return (ns === null? '' : ns + ':') + l;
        },
    function(lead, first, chars) { return chars.join(''); },
    function(lead, first, rest) {
            var label = first + (rest? rest.join('') : '');
            return {'@id': lead + label};
        },
    function(tag, subtag) {
            var sub = (subtag.length? subtag.map(function (it) {
                return it[0] + it[1].join(''); }).join('') : '');
            return {"@language": tag.join('') + sub};
        },
    function(sign, digits) {
            var i = parseInt(digits.join(''), 10);
            if (sign === '-')
                i = -1 * i;
            return i;
        },
    function(sign, whole, fraction) {
                return (whole? whole.join('') : '') + '.' + fraction.join('');
            },
    function(sign, digits) {
            return parseFloat((sign || '') + digits, 10);
        },
    function(sign, whole, fraction, exp) {
                return whole.join('') + '.' +
                    (fraction? fraction.join('') : '') + exp;
            },
    function(sign, fraction, exp) {
                return fraction.join('') + exp;
            },
    function(sign, whole, exp) {
                return whole.join('') + exp;
            },
    function(e, sign, digits) {
            return e + (sign || '') + digits.join('');
        },
    function(value) {
            return value.join('');
        },
    function(first, rest) { return (first || '') + rest; },
    function(hex) {
            return String.fromCharCode(parseInt(hex.join(''), 16));
        },
    function(chr) {
            return echars[chr];
        },
    function() { return {}; },
    function(first, chars) { return chars.join(''); },
    function(first, rest) {
            return first + (rest? rest.join('') : '');
        },
    function(a, b) { return '%' + a + b; },
    function(chr) {
            return chr;
        }
  ];

  var peg$bytecode = [
    peg$decode("%;X$;'.# &;!0)*;'.# &;!&;X8#: $!!"),
    peg$decode(";\".f &%;$/' 8!:!!! ).T &;#.N &%;X7 3 \"!5%#/:$;&/1$;$/($8$:\"%\"! ($'#(#'#(\"'#"),
    peg$decode("%;&/X#;$.D &%;-/:#;X7!2!\"!6!#/($8#:#$\"$\"(#'#&'#/($8\":$#\"! (\"'#&'#"),
    peg$decode("%;4/A#;-.\" &\";X7!2!\"!6!#/($8$:%%\"#\"($'#&'#.M &%;5/C#;-/:$;X7!2!\"!6!#/($8$:&%\"#\"($'#(\"'#&'#"),
    peg$decode("%;X7\"2\"\"!6\"#/B$;%.\" &\";X7#2#\"!6##/)$;X8&:''!#(%'#(\"'#"),
    peg$decode("%;,/L#%7!2!\"!6!#//#;%.\" &\"8\":(#\"# &'#.\" &\"8\":)#\"! &'#"),
    peg$decode(";:.# &;<"),
    peg$decode(";(./ &;).) &;*.# &;+"),
    peg$decode("%7$2$\"!6$#/R#;X;>/G$;X;=/<$;X7!2!\"!6!#/*$;X8(:*)\"%#(''#(%'#(#'#&'#"),
    peg$decode("%7%2%\"!6%#/F#;X;=/;$;X7!2!\"!6!#/)$;X8&:+'!#(%'#(#'#&'#"),
    peg$decode("%7&3&\"!5&#/@#;X;>/5$;X;=/*$;X8&:*'\"#!(%'#(#'#&'#"),
    peg$decode("%7'3'\"!5$#/4#;X;=/)$;X8$:+%!!(#'#&'#"),
    peg$decode("%;0/1#;-/($8\":,#\"! (\"'#&'#.4 &%;4/*#;-.\" &\"+\")&'#"),
    peg$decode("%;//\x9F#;./\x96$$%7(2(\"!6(#/C#%;//,#;./#$+\")(\"'#&'#.\" &\"8\":-##%$ &'#0T*%7(2(\"!6(#/C#%;//,#;./#$+\")(\"'#&'#.\" &\"8\":-##%$ &'#&;X8$:.%##\"!(\"'#&'#"),
    peg$decode("%;1/y#$%;X7)2)\"!6)#/3$;X;1/($8$:/%\"& ($'#(\"'#0G*%;X7)2)\"!6)#/3$;X;1/($8$:/%\"& ($'#(\"'#&8\":0#\"! &'#"),
    peg$decode("%;X;:.5 &%7*2*\"!6*#/& 8!:1! )/)$;X8#:2$!!(\"'#"),
    peg$decode(";:.# &;3"),
    peg$decode(";:./ &;3.) &;4.# &;2"),
    peg$decode("%;X;7.) &;6.# &;8/)$;X8#:3$!!(\"'#"),
    peg$decode(";<.# &;5"),
    peg$decode("%;X7+2+\"!6+#/B$;-/9$7,2,\"!6,#/)$;X8%:4&!\"($'#(#'#(\"'#"),
    peg$decode("%;X7-2-\"!6-#/F$;X$;10#*;1&;X7.2.\"!6.#/)$;X8':5(!#(&'#(\"'#"),
    peg$decode(";D.) &;C.# &;B"),
    peg$decode("%;9/T#;A.B &%7/2/\"!6/#/1#;:/($8\":6#\"# (\"'#&'#.\" &\"8\":7#\"! &'#"),
    peg$decode("%7020\"!60#/& 8!:8! ).5 &%7121\"!61#/& 8!:9! )"),
    peg$decode("%;X;H./ &;I.) &;F.# &;G/)$;X8#::$!!(\"'#"),
    peg$decode("%;X;=.# &;;/)$;X8#:;$!!(\"'#"),
    peg$decode("%;?.# &;>/' 8!:<!! )"),
    peg$decode("%;X;@.# &;N/)$;X8#:=$!!(\"'#"),
    peg$decode("%7222\"!62#/Z#$734 \"!5!#.# &;J00*734 \"!5!#.# &;J&7423\"!63#/'$8#:>$!!(#'#&'#"),
    peg$decode("%;R.\" &\"7524\"!64#/'$8\":?#!!(\"'#"),
    peg$decode("%;>/1#;S/($8\":@#\"! (\"'#&'#"),
    peg$decode("%7625\"!65#/\xA4#;P.* &774!\"!5!#/\x8E$$%%7!2!\"!6!#/,#;Q/#$+\")(\"'#&'#/) 8!:A!#$# ).# &;Q0Q*%%7!2!\"!6!#/,#;Q/#$+\")(\"'#&'#/) 8!:A!#$# ).# &;Q&8#:B$#\"! (\"'#&'#"),
    peg$decode("%7826\"!66#/\xBF#$794\"\"!5!#/-#0**794\"\"!5!#&&&#/\x9B$$%7:27\"!67#/G#$7;4#\"!5!#/-#0**7;4#\"!5!#&&&#/#$+\")(\"'#&'#0X*%7:27\"!67#/G#$7;4#\"!5!#/-#0**7;4#\"!5!#&&&#/#$+\")(\"'#&'#&8#:C$\"! (\"'#&'#"),
    peg$decode("%7<4$\"!5!#.\" &\"$774!\"!5!#/-#0**774!\"!5!#&&&#/($8\":D#\"! (\"'#"),
    peg$decode("%7<4$\"!5!#.\" &\"%$774!\"!5!#0**774!\"!5!#&7!2!\"!6!#/M$$774!\"!5!#/-#0**774!\"!5!#&&&#/)$8#:E$#$\" (#'#(\"'#/($8\":F#\"! (\"'#"),
    peg$decode("%7<4$\"!5!#.\" &\"%$774!\"!5!#/-#0**774!\"!5!#&&&#/Z#7!2!\"!6!#/J$$774!\"!5!#0**774!\"!5!#&;E/*$8$:G%$%#! ($'#(\"'#&'#.\xA1 &%7!2!\"!6!#/V#$774!\"!5!#/-#0**774!\"!5!#&&&#/2$;E/)$8#:H$#$! (#'#(\"'#&'#.W &%$774!\"!5!#/-#0**774!\"!5!#&&&#/2#;E/)$8\":I###! (\"'#&'#/($8\":F#\"! (\"'#"),
    peg$decode("%7=4%\"!5!#/[#7<4$\"!5!#.\" &\"$774!\"!5!#/-#0**774!\"!5!#&&&#/)$8#:J$#\"! (#'#&'#"),
    peg$decode("%7>28\"!68#/f#$7?4&\"!5!#.) &;K.# &;J06*7?4&\"!5!#.) &;K.# &;J&7>28\"!68#/'$8#:K$!!(#'#&'#"),
    peg$decode("%7@29\"!69#/f#$7A4'\"!5!#.) &;K.# &;J06*7A4'\"!5!#.) &;K.# &;J&7@29\"!69#/'$8#:K$!!(#'#&'#"),
    peg$decode("%7B2:\"!6:#/\xBC#$%7@29\"!69#.* &7C2;\"!6;#.\" &\"7D4(\"!5!#.) &;K.# &;J/($8\":L#\"! (\"'#0a*%7@29\"!69#.* &7C2;\"!6;#.\" &\"7D4(\"!5!#.) &;K.# &;J/($8\":L#\"! (\"'#&7B2:\"!6:#/'$8#:K$!!(#'#&'#"),
    peg$decode("%7E2<\"!6<#/\xBC#$%7>28\"!68#.* &7F2=\"!6=#.\" &\"7G4)\"!5!#.) &;K.# &;J/($8\":L#\"! (\"'#0a*%7>28\"!68#.* &7F2=\"!6=#.\" &\"7G4)\"!5!#.) &;K.# &;J/($8\":L#\"! (\"'#&7E2<\"!6<#/'$8#:K$!!(#'#&'#"),
    peg$decode("%7H2>\"!6>#/U#%;V/>#;V/5$;V/,$;V/#$+$)($'#(#'#(\"'#&'#/'$8\":M#! (\"'#&'#.\x8A &%7I2?\"!6?#/y#%;V/b#;V/Y$;V/P$;V/G$;V/>$;V/5$;V/,$;V/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/'$8\":M#! (\"'#&'#"),
    peg$decode("%7J2@\"!6@#/7#7K4*\"!5!#/'$8\":N#! (\"'#&'#"),
    peg$decode("%2-\"!6-#/3#;X2.\"!6.#/#$+#)(#'#&'#"),
    peg$decode("7L2A\"!6A#.D &7M2B\"!6B#.7 &7N2C\"!6C#.* &7O2D\"!6D#"),
    peg$decode("%7+2+\"!6+#/8#;X7,2,\"!6,#/&$8#:O$ (#'#&'#"),
    peg$decode("7P4+\"!5!#.\xB9 &7Q4,\"!5!#.\xAC &7R4-\"!5!#.\x9F &7S4.\"!5!#.\x92 &7T4/\"!5!#.\x85 &7U40\"!5!#.x &7V41\"!5!#.k &7W42\"!5!#.^ &7X43\"!5!#.Q &7Y44\"!5!#.D &7Z45\"!5!#.7 &7[46\"!5!#.* &7\\47\"!5!#"),
    peg$decode(";O.* &7]2E\"!6E#"),
peg$decode(";P.^ &7:27\"!67#.Q &774!\"!5!#.D &7^2F\"!6F#.7 &7_48\"!5!#.* &7`49\"!5!#"),
    peg$decode("%;O/\x8B#$%%7!2!\"!6!#/,#;Q/#$+\")(\"'#&'#/( 8!:P!\"# ).# &;Q0P*%%7!2!\"!6!#/,#;Q/#$+\")(\"'#&'#/( 8!:P!\"# ).# &;Q&8\":Q#\"! &'#"),
    peg$decode("%;P.= &7524\"!64#.0 &774!\"!5!#.# &;T/\u0109#$%%;Q.= &7!2!\"!6!#.0 &7524\"!64#.# &;T/?#;Q.0 &7524\"!64#.# &;T/#$+\")(\"'#&'#/( 8!:P!\"# ).6 &;Q.0 &7524\"!64#.# &;T0\x8F*%%;Q.= &7!2!\"!6!#.0 &7524\"!64#.# &;T/?#;Q.0 &7524\"!64#.# &;T/#$+\")(\"'#&'#/( 8!:P!\"# ).6 &;Q.0 &7524\"!64#.# &;T&8\":Q#\"! &'#"),
    peg$decode(";U.# &;W"),
    peg$decode("%7a2G\"!6G#/:#;V/1$;V/($8#:R$\"! (#'#(\"'#&'#"),
    peg$decode("774!\"!5!#.7 &7b4:\"!5!#.* &7c4;\"!5!#"),
    peg$decode("%7J2@\"!6@#/\u012E#7]2E\"!6E#.\u0114 &7d2H\"!6H#.\u0107 &7!2!\"!6!#.\xFA &7:27\"!67#.\xED &7e2I\"!6I#.\xE0 &7f2J\"!6J#.\xD3 &7g2K\"!6K#.\xC6 &7@29\"!69#.\xB9 &7-2-\"!6-#.\xAC &7.2.\"!6.#.\x9F &7h2L\"!6L#.\x92 &7i2M\"!6M#.\x85 &7)2)\"!6)#.x &7(2(\"!6(#.k &7j2N\"!6N#.^ &7k2O\"!6O#.Q &7l2P\"!6P#.D &7m2Q\"!6Q#.7 &7826\"!66#.* &7a2G\"!6G#/'$8\":S#! (\"'#&'#"),
    peg$decode("$;M.[ &%7m2Q\"!6Q#/J#$7n4<\"!5!#0**7n4<\"!5!#&7o4=\"!5!#/#$+#)(#'#&'#0a*;M.[ &%7m2Q\"!6Q#/J#$7n4<\"!5!#0**7n4<\"!5!#&7o4=\"!5!#/#$+#)(#'#&'#&")
  ];

  var peg$currPos = 0;
  var peg$savedPos = 0;
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
  var peg$expected = [];
  var peg$silentFails = 0;

  var peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function offset() {
    return peg$savedPos;
  }

  function range() {
    return [peg$savedPos, peg$currPos];
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  var peg$VALIDFILENAME = typeof options.filename === "string" && options.filename.length > 0;
  function peg$computeLocation(startPos, endPos) {
    var loc = {};

    if ( peg$VALIDFILENAME ) loc.filename = options.filename;

    var startPosDetails = peg$computePosDetails(startPos);
    loc.start = {
      offset: startPos,
      line: startPosDetails.line,
      column: startPosDetails.column
    };

    var endPosDetails = peg$computePosDetails(endPos);
    loc.end = {
      offset: endPos,
      line: endPosDetails.line,
      column: endPosDetails.column
    };

    return loc;
  }

  function peg$begin() {
    peg$expected.push({ pos: peg$currPos, variants: [] });
  }

  function peg$expect(expected) {
    var top = peg$expected[peg$expected.length - 1];

    if (peg$currPos < top.pos) { return; }

    if (peg$currPos > top.pos) {
      top.pos = peg$currPos;
      top.variants = [];
    }

    top.variants.push(expected);
  }

  function peg$end(invert) {
    var expected = peg$expected.pop();
    var top = peg$expected[peg$expected.length - 1];
    var variants = expected.variants;

    if (top.pos !== expected.pos) { return; }

    if (invert) {
      variants = variants.map(function(e) {
        return e.type === "not" ? e.expected : { type: "not", expected: e };
      });
    }

    Array.prototype.push.apply(top.variants, variants);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$buildError() {
    var expected = peg$expected[0];
    var failPos = expected.pos;

    return peg$buildStructuredError(
      expected.variants,
      failPos < input.length ? input.charAt(failPos) : null,
      failPos < input.length
        ? peg$computeLocation(failPos, failPos + 1)
        : peg$computeLocation(failPos, failPos)
    );
  }

  function peg$decode(s) {
    return s.split("").map(function(ch) { return ch.charCodeAt(0) - 32; });
  }

  function peg$parseRule(index) {
    var bc = peg$bytecode[index];
    var ip = 0;
    var ips = [];
    var end = bc.length;
    var ends = [];
    var stack = [];
    var params, paramsLength, paramsN;

    var rule$expects = function (expected) {
      if (peg$silentFails === 0) peg$expect(expected);
    }

    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push('');
            ip++;
            break;

          case 1:
            stack.push(undefined);
            ip++;
            break;

          case 2:
            stack.push(null);
            ip++;
            break;

          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;

          case 4:
            stack.push([]);
            ip++;
            break;

          case 5:
            stack.push(peg$currPos);
            ip++;
            break;

          case 6:
            stack.pop();
            ip++;
            break;

          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;

          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;

          case 9:
            stack.splice(-2, 1);
            ip++;
            break;

          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;

          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;

          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;

          case 41:
            paramsLength = bc[ip + 2];
            paramsN = 3 + paramsLength

            params = bc.slice(ip + 3, ip + paramsN);
            params = paramsLength === 1
              ? stack[stack.length - 1 - params[ 0 ]]
              : params.map(function(p) { return stack[stack.length - 1 - p]; });

            stack.splice(
              stack.length - bc[ip + 1],
              bc[ip + 1],
              params
            );

            ip += paramsN;
            break;

          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);

              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }

            break;

          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$literals[bc[ip + 1]].length) === peg$literals[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$literals[bc[ip + 1]].length).toLowerCase() === peg$literals[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (peg$regexps[bc[ip + 1]].test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;

          case 22:
            stack.push(peg$literals[bc[ip + 1]]);
            peg$currPos += peg$literals[bc[ip + 1]].length;
            ip += 2;
            break;

          case 23:
            rule$expects(peg$expectations[bc[ip + 1]]);
            ip += 2;
            break;

          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;

          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;

          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
              .map(function(p) { return stack[stack.length - 1 - p]; });

            stack.splice(
              stack.length - bc[ip + 2],
              bc[ip + 2],
              peg$functions[bc[ip + 1]].apply(null, params)
            );

            ip += 4 + bc[ip + 3];
            break;

          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;

          case 28:
            peg$silentFails++;
            ip++;
            break;

          case 29:
            peg$silentFails--;
            ip++;
            break;

          case 38:
            peg$begin();
            ip++;
            break;

          case 39:
            peg$end(bc[ip + 1]);
            ip += 2;
            break;

          // istanbul ignore next
          default:
            throw new Error(
              "Rule #" + index + ", position " + ip + ": "
              + "Invalid opcode " + bc[ip] + "."
            );
        }
      }

      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }

    return stack[0];
  }



      function assign(target, source) {
          for (var key in source) {
              target[key] = source[key];
          }
          return target;
      }

      function contextItem(key, value) {
          var decl = {}
          decl[key] = value;
          return {'@context': decl};
      }

      function prefix(pfx, iriref) {
          return contextItem(pfx || '@vocab', iriref['@id']);
      }

      function base(iriref) {
          return contextItem('@base', iriref['@id']);
      }

      var PNAME_TAG = "_:neverspace.net,2016-01-10:ldtr:pname";

      function toSymbols(objectList) {
          function reducePname(o) {
              return o[PNAME_TAG]? o['@id'] : o;
              // TODO: if value is not a string, item need to use rdf:type as
              // key for those values instead of @type
          }
          if (Array.isArray(objectList)) {
              return objectList.map(function (o) {
                  return reducePname(o);
              });
          } else {
              return reducePname(objectList);
          }
      }

      function toPair(verb, objectList) {
          var po = {};
          po[verb] = objectList;
          return po;
      }

      function reducePairs(subject, pairs) {
          if (subject === null) {
              subject = '';
          }
          if (typeof subject === 'string') {
              if (subject.indexOf(':') === -1) {
                  subject = ':' + subject;
              }
              subject = {'@id': subject};
          }
          for (var pair of pairs) {
              for (var key in pair) {
                  var value = pair[key];
                  var existing = subject[key];
                  if (typeof existing !== 'undefined') {
                      if (!Array.isArray(existing)) {
                          existing = [existing];
                      }
                      if (Array.isArray(value)) {
                          existing = existing.concat(value);
                      } else {
                          existing.push(value);
                      }
                      value = existing;
                  }
                  subject[key] = value;
              }
          }
          return subject;
      }

      var echars = {
          t: '\t',
          b: '\b',
          n: '\n',
          r: '\r',
          f: '\f',
          '"': '"',
          "'": "'",
          '\\': '\\'
      };



  peg$begin();
  peg$result = peg$parseRule(peg$startRuleIndex);

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$expect(peg$endExpectation());
    }

    throw peg$buildError();
  }
}

export {
  peg$SyntaxError as SyntaxError,
  peg$parse as parse
};

export default {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse
};
