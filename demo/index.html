<!DOCTYPE html>
<title>LDTR Demo</title>
<meta charset="utf-8" />

<link rel="stylesheet" href="visualizer.css" />
<style>

  #view {
    font-family: verdana;
    font-size: 12px;
    color: #000;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    overflow: auto;
    padding: 1em 1.5em;
  }

  body.edit #view {
    right: 50%;
  }

  #edit {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 50%;
    overflow: auto;
    visibility: hidden;
  }

  body.edit #edit {
    visibility: visible;
    background-color: #eee;
    box-shadow: 0px 0px 6px 2px rgba(0,0,0,0.4);
    padding: 0.2em;
  }

  .editor {
    visibility: hidden;
    font-family: Courier;
    font-size: 12px;
    width: 99%;
    height: 92%;
  }

  body.edit .editor {
    visibility: visible;
  }

</style>

<section id="view">
</section>
<section id="edit">
  <textarea class="editor" rows="40"></textarea>
  <div class="status"></div>
</section>

<script src="visualizer.js"></script>
<script type="module">

  import {read} from '../lib/xhtreqreader.js'
  import * as reader from '../lib/reader.js'

  var ldtrDemo = {

    init: function () {
      this.viewDiv = document.getElementById('view');
      this.editorArea = document.querySelector('#edit > .editor');
      this.statusDiv = document.querySelector('#edit > .status');
      this.editorArea.onkeyup = function () {
        this.parseAndValidate();
      }.bind(this);

      var query = window.location.search.substring(1),
        params = query.split(/\&/).reduce(function (map, pair) {
          var tuple = pair.split(/=/);
          map[tuple[0]] = tuple[1];
          return map;
        }, {});

      if (!params.url || params.edit) {
        document.body.classList.add('edit');
      }

      this.loadData(params.url);
    },

    loadData: function (url) {
      if (!url) return;

      read(url, reader.getHeaders().accept).then(
        async (result) => {
          let {data, url, contentType} = result
          this.editorArea.value = data;
          this.editorArea.dataset.url = url;
          this.editorArea.dataset.contentType = contentType;

          await this.parseAndValidate();
          // force browser to recognize dynamically generated :target
          if (window.location.hash) {
            window.location = window.location.hash;
          }
        },
        e => {
          if (!e.location)
            throw e;
          this.statusDiv.innerText += e.name +' at Line: '+ e.location.start.line
            +' Col: '+ e.location.start.column +'\n'+ e.message;
          return;
        }
      )
    },

    parseAndValidate: async function () {
      let url  = this.editorArea.dataset.url
      let contentType = this.editorArea.dataset.contentType
      let data = this.editorArea.value

      if (contentType && contentType.match(/xml/)) return;

      let transcriber = reader.transcribers[contentType]
      let result = await transcriber(data, url, contentType)

      var pos = this.editorArea.selectionStart;
      var row = 1;
      var col = 1;
      for (var i=0; i < pos; i++) {
        if (data[i] === '\n') {
          row += 1;
          col = 1;
        } else {
          col++;
        }
      }
      this.statusDiv.innerText = 'Line: '+ row +' Col: '+ col +' \n';
      this.statusDiv.innerText += "OK";

      visualize(this.viewDiv, result);
    }

  };

  window.onload = ldtrDemo.init();

</script>
